---
title: "API Reference"
---

This section provides a detailed reference for the public API of the `naq` library.

The API is organized into modules, each providing specific functionality.

## Core Modules

-   [**`queue` Module**](queue.qmd): The primary interface for enqueuing and scheduling jobs. Includes the `Queue` class and helper functions like `enqueue`, `enqueue_at`, and `schedule`.

-   [**`job` Module**](job.qmd): Defines the `Job` class, which represents a unit of work to be executed.

-   [**`worker` Module**](worker.qmd): Contains the `Worker` class, responsible for executing jobs from one or more queues.

-   [**`scheduler` Module**](scheduler.qmd): Contains the `Scheduler` class, responsible for enqueuing scheduled and recurring jobs.

-   [**`events` Module**](events.qmd): Provides the event logging and monitoring system, including `JobEvent`, `AsyncJobEventLogger`, and `AsyncJobEventProcessor`.

-   [**`exceptions` Module**](exceptions.qmd): Defines custom exceptions raised by `naq`.

## Service Layer

The service layer provides a centralized architecture for managing resources and dependencies in `naq`. It eliminates connection duplication and provides a clean, maintainable way to handle NATS connections, streams, KV stores, and other resources.

-   [**`services` Package**](services.qmd): Core service infrastructure including base classes and service manager.

### Core Services

-   [**`ConnectionService`**](services/connection.py): Manages NATS connections and JetStream contexts with connection pooling, retry logic, and health monitoring.

-   [**`StreamService`**](services/streams.py): Handles NATS JetStream stream operations including creation, configuration, and management.

-   [**`KVStoreService`**](services/kv_stores.py): Manages NATS Key-Value store operations with TTL support and transaction capabilities.

-   [**`JobService`**](services/jobs.py): Handles job execution, result storage, and failure handling with proper error management.

-   [**`EventService`**](services/events.py): Manages event logging, batching, and processing with efficient buffering and streaming.

-   [**`SchedulerService`**](services/scheduler.py): Handles scheduled job management, triggering, and persistence.

### Service Infrastructure

-   [**`BaseService`**](services/base.py): Abstract base class for all services with lifecycle management.

-   [**`ServiceManager`**](services/base.py): Central service registry and dependency injection container.

### Service Usage

The service layer is designed to be used transparently by the core `naq` components, but can also be used directly for advanced use cases:

```python
import asyncio
from naq.services import ServiceManager, ConnectionService, StreamService
from naq.queue import Queue

async def service_example():
    # Create service configuration
    config = {
        'nats': {
            'url': 'nats://localhost:4222',
            'max_reconnect_attempts': 5,
            'reconnect_delay': 1.0
        }
    }
    
    # Use ServiceManager for lifecycle management
    async with ServiceManager(config) as services:
        # Services are automatically created and managed
        queue = Queue(name='example', services=services)
        
        # Queue uses services internally for all operations
        job = await queue.enqueue(my_function, arg1, arg2)
        
        # Services are automatically cleaned up when context exits
```

For more detailed information about the service layer architecture and advanced usage patterns, see the [Service Layer Architecture](../architecture.qmd#service-layer-architecture) section in the architecture documentation.

## Utils Package

The utils package provides a comprehensive collection of utilities extracted from various modules throughout the codebase. It offers common functionality used across all components of `naq`, eliminating code duplication and providing consistent tools for common operations.

-   [**`utils` Package**](utils.qmd): Core utilities including async helpers, configuration management, error handling, logging, NATS helpers, retry mechanisms, serialization, timing, types, and validation.

### Core Utils Modules

-   **[`async_helpers`](utils.qmd#async-helpers)**: Utilities for bridging synchronous and asynchronous code, including `run_async()`, `run_sync()`, and conversion decorators.

-   **[`config`](utils.qmd#config)**: Configuration management system with multiple source support, including `ConfigManager`, environment variables, file-based config, and dataclass loading.

-   **[`context_managers`](utils.qmd#context-managers)**: Common context managers for resource management, including `managed_resource()`, `timeout_context()`, and `retry_context()`.

-   **[`decorators`](utils.qmd#decorators)**: Reusable decorators for common patterns, including `retry_decorator()`, `timeout_decorator()`, `benchmark_decorator()`, and `log_errors()`.

-   **[`error_handling`](utils.qmd#error-handling)**: Centralized error handling and reporting, including `ErrorContext`, `ErrorCategory`, `ErrorHandler`, and recovery strategies.

-   **[`logging`](utils.qmd#logging)**: Comprehensive logging utilities, including structured logging, performance logging, log handler management, and log correlation.

-   **[`nats_helpers`](utils.qmd#nats-helpers)**: NATS-specific utilities extracted from connection modules, including connection management, stream operations, KV store operations, subject utilities, and message handling.

-   **[`retry`](utils.qmd#retry)**: Comprehensive retry system with `RetryConfig`, `retry_async()`, `retry()`, various retry strategies, and jitter support.

-   **[`serialization`](utils.qmd#serialization)**: Serialization utilities for jobs and results, including `JobSerializer`, `ResultSerializer`, `SecureSerializer`, and extensible serializer protocols.

-   **[`timing`](utils.qmd#timing)**: Performance measurement and timing utilities, including `Timer`, `AsyncTimer`, `Benchmark`, `Scheduler`, and performance tracking.

-   **[`types`](utils.qmd#types)**: Comprehensive type definitions for the entire system, including basic type aliases, protocol definitions, generic types, validation helpers, and model types.

-   **[`validation`](utils.qmd#validation)**: Comprehensive validation utilities, including type validation, range validation, choice validation, string validation, URL/email validation, dictionary validation, and dataclass validation.

### Utils Usage Examples

The utils package is designed to be used throughout all components of `naq`. Here are some common usage patterns:

#### Configuration Management
```python
from naq.utils.config import ConfigManager, EnvironmentConfigSource, load_naq_config

# Load configuration with multiple sources
config_manager = ConfigManager([
    EnvironmentConfigSource(prefix="NAQ_"),
    FileConfigSource("naq.yaml")
])

# Get typed configuration values
max_retries = config_manager.get_typed("job.max_retries", int, 3)
timeout = config_manager.get_required_typed("connection.timeout", float)

# Load predefined configuration structures
naq_config = load_naq_config(config_manager)
```

#### Error Handling
```python
from naq.utils import ErrorContext, ErrorCategory, ErrorReporter

async def process_job(job):
    try:
        result = await job.execute()
        return result
    except Exception as e:
        error_context = ErrorContext(
            operation="job_execution",
            exception=e,
            job_id=job.id
        )
        error_context.category = ErrorCategory.EXECUTION
        
        reporter = ErrorReporter()
        await reporter.report_error(error_context)
        raise
```

#### NATS Operations
```python
from naq.utils.nats_helpers import nats_jetstream_context, create_stream_with_retry

async def setup_stream():
    async with nats_jetstream_context() as (conn, js):
        stream_info = await create_stream_with_retry(
            js,
            StreamConfigHelper(
                name="MY_STREAM",
                subjects=["my.subject.*"]
            )
        )
        return stream_info
```

#### Performance Monitoring
```python
from naq.utils import Timer, Benchmark
from naq.utils.logging import get_structured_logger

async def process_with_monitoring(item):
    logger = get_structured_logger("processor")
    
    with Timer() as timer:
        result = await self._process_item(item)
        
        logger.info(
            "Item processed",
            item_id=item.id,
            duration=timer.duration
        )
        
        return result

def benchmark_processing():
    benchmark = Benchmark()
    
    with benchmark:
        for i in range(1000):
            process_with_monitoring(f"item_{i}")
    
    print(f"Average time: {benchmark.average_time:.4f}s")
```

#### Retry Logic
```python
from naq.utils.retry import RetryConfig, retry_async

async def unreliable_operation():
    # This might fail
    pass

async def robust_operation():
    retry_config = RetryConfig(
        max_attempts=3,
        base_delay=1.0,
        max_delay=10.0,
        retryable_exceptions=(ConnectionError, TimeoutError)
    )
    
    return await retry_async(unreliable_operation, config=retry_config)
```

For more detailed information about the utils package architecture and comprehensive API documentation, see the [Utils Package Architecture](../architecture.qmd#utils-package-architecture) section in the architecture documentation.