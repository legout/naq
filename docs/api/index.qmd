---
title: "API Reference"
---

This section provides a detailed reference for the public API of the `naq` library.

The API is organized into modules, each providing specific functionality.

## Core Modules

-   [**`queue` Module**](queue.qmd): The primary interface for enqueuing and scheduling jobs. Includes the `Queue` class and helper functions like `enqueue`, `enqueue_at`, and `schedule`.

-   [**`job` Module**](job.qmd): Defines the `Job` class, which represents a unit of work to be executed.

-   [**`worker` Module**](worker.qmd): Contains the `Worker` class, responsible for executing jobs from one or more queues.

-   [**`scheduler` Module**](scheduler.qmd): Contains the `Scheduler` class, responsible for enqueuing scheduled and recurring jobs.

-   [**`events` Module**](events.qmd): Provides the event logging and monitoring system, including `JobEvent`, `AsyncJobEventLogger`, and `AsyncJobEventProcessor`.

-   [**`exceptions` Module**](exceptions.qmd): Defines custom exceptions raised by `naq`.

## Service Layer

The service layer provides a centralized architecture for managing resources and dependencies in `naq`. It eliminates connection duplication and provides a clean, maintainable way to handle NATS connections, streams, KV stores, and other resources.

-   [**`services` Package**](services.qmd): Core service infrastructure including base classes and service manager.

### Core Services

-   [**`ConnectionService`**](services/connection.py): Manages NATS connections and JetStream contexts with connection pooling, retry logic, and health monitoring.

-   [**`StreamService`**](services/streams.py): Handles NATS JetStream stream operations including creation, configuration, and management.

-   [**`KVStoreService`**](services/kv_stores.py): Manages NATS Key-Value store operations with TTL support and transaction capabilities.

-   [**`JobService`**](services/jobs.py): Handles job execution, result storage, and failure handling with proper error management.

-   [**`EventService`**](services/events.py): Manages event logging, batching, and processing with efficient buffering and streaming.

-   [**`SchedulerService`**](services/scheduler.py): Handles scheduled job management, triggering, and persistence.

### Service Infrastructure

-   [**`BaseService`**](services/base.py): Abstract base class for all services with lifecycle management.

-   [**`ServiceManager`**](services/base.py): Central service registry and dependency injection container.

### Service Usage

The service layer is designed to be used transparently by the core `naq` components, but can also be used directly for advanced use cases:

```python
import asyncio
from naq.services import ServiceManager, ConnectionService, StreamService
from naq.queue import Queue

async def service_example():
    # Create service configuration
    config = {
        'nats': {
            'url': 'nats://localhost:4222',
            'max_reconnect_attempts': 5,
            'reconnect_delay': 1.0
        }
    }
    
    # Use ServiceManager for lifecycle management
    async with ServiceManager(config) as services:
        # Services are automatically created and managed
        queue = Queue(name='example', services=services)
        
        # Queue uses services internally for all operations
        job = await queue.enqueue(my_function, arg1, arg2)
        
        # Services are automatically cleaned up when context exits
```

For more detailed information about the service layer architecture and advanced usage patterns, see the [Service Layer Architecture](../architecture.qmd#service-layer-architecture) section in the architecture documentation.

## Utils Package

The `utils` package provides a comprehensive collection of utilities extracted from various modules throughout the codebase. It eliminates code duplication and provides consistent, well-tested functionality across all components of `naq`.

-   [**`utils` Package**](utils.qmd): Comprehensive utilities for common operations including async helpers, configuration management, error handling, logging, NATS helpers, retry mechanisms, serialization, timing, types, and validation.

### Core Utility Modules

The utils package is organized into specialized modules, each focusing on a specific area of functionality:

-   **[`decorators`](utils.qmd#decorators)**: Reusable decorators for common patterns
-   **[`context_managers`](utils.qmd#context-managers)**: Common context managers for resource management
-   **[`async_helpers`](utils.qmd#async-helpers)**: Utilities for bridging synchronous and asynchronous code
-   **[`error_handling`](utils.qmd#error-handling)**: Centralized error handling and reporting
-   **[`logging`](utils.qmd#logging)**: Comprehensive logging utilities and formatters
-   **[`serialization`](utils.qmd#serialization)**: Serialization utilities for jobs and results
-   **[`validation`](utils.qmd#validation)**: Comprehensive validation utilities
-   **[`timing`](utils.qmd#timing-and-benchmarking)**: Performance measurement and timing utilities
-   **[`nats_helpers`](utils.qmd#nats-helpers)**: NATS-specific utilities
-   **[`types`](utils.qmd#type-definitions)**: Comprehensive type definitions for the entire system

### Integration with Core Components

The utils package integrates seamlessly with all core components of `naq`, providing consistent functionality and eliminating code duplication:

```python
from naq.utils import Timer, ErrorContext
from naq.utils.decorators import retry
from naq.utils.nats_helpers import nats_jetstream_context
from naq.utils.logging import get_structured_logger

# Example usage in a component
async def process_request(self, request):
    with Timer() as timer:
        logger = get_structured_logger("component")
        
        try:
            async with nats_jetstream_context() as (conn, js):
                result = await retry(
                    self._process_impl,
                )(request, js)
                
                logger.info(
                    "Request processed",
                    request_id=request.id,
                    duration=timer.duration
                )
                return result
                
        except Exception as e:
            error_context = ErrorContext(
                operation="request_processing",
                exception=e,
                request_id=request.id
            )
            logger.error("Request failed", error_context=error_context)
            raise
```

For more detailed information about the utils package architecture and usage patterns, see the [Utils Package Architecture](../architecture.qmd#utils-package-architecture) section in the architecture documentation.