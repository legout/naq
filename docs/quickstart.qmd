---
title: "Quickstart Guide"
---

This guide will walk you through the basics of setting up a task, enqueuing it, and running a worker to process it.

## 1. Set Up Configuration (Optional)

While not required for this quickstart, NAQ supports comprehensive YAML-based configuration that's useful for production deployments. For now, we'll use the defaults, but you can create a configuration file:

```bash
# Create a development configuration file (optional)
naq system config-init --environment development
```

This creates a `naq.yaml` file with sensible defaults. For this quickstart, the built-in defaults will work fine.

## 2. Define a Task

First, create a Python file to define the function you want to run in the background. Let's call this file `tasks.py`.

This function can be any regular Python function. For this example, we'll create a simple function that simulates some work and counts the words in a given text.

```python
# tasks.py
import time
import random

def count_words(text):
    """
    A simple function that counts the words in a string.
    """
    print(f"Processing text: '{text[:30]}...'")
    # Simulate some I/O or CPU-bound work
    time.sleep(random.randint(1, 3))
    word_count = len(text.split())
    print(f"Found {word_count} words.")
    return word_count
```

## 3. Enqueue the Job

Now, let's enqueue the `count_words` function to be executed by a worker. Create another file, `main.py`, to send the job to the queue.

We'll use the `enqueue_sync` function, which is a simple, blocking way to add a job to the queue.

```python
# main.py
from naq import enqueue_sync  # Main API (backward compatible)
from tasks import count_words

# Alternative: Use new modular imports (optional)
# from naq.queue.sync_api import enqueue_sync

# The text we want to process
long_text = (
    "A journey of a thousand miles begins with a single step. "
    "The best time to plant a tree was 20 years ago. "
    "The second best time is now."
)

print("Enqueuing job to count words...")

# Enqueue the function `count_words` with `long_text` as its argument
job = enqueue_sync(count_words, long_text)

print(f"Successfully enqueued job {job.job_id}.")
print("To process the job, run a worker with: naq worker default")
```

## 4. Run the Worker

With the job enqueued, the final step is to start a worker process. The worker will connect to NATS, fetch the job from the queue, and execute the `count_words` function.

Open your terminal and run the following command:

```bash
naq worker default
```

The `default` argument tells the worker to listen to the default queue, which is where `enqueue_sync` sends jobs.

You should see output similar to this in your worker's terminal:

```
14:30:15.123 INFO     Worker listening on queue: naq_default_queue
Processing text: 'A journey of a thousand miles...'
Found 25 words.
14:30:18.245 INFO     Job 1a2b3c4d completed. Result: 25
```

Congratulations! You've successfully enqueued and processed your first background job with `naq`.

## 5. Monitor Your Jobs

One of NAQ's most powerful features is its comprehensive event-driven monitoring system. Every job operation is logged as structured events that you can monitor in real-time.

### Real-time Job Monitoring

Open a new terminal and run the events monitor to see your jobs in action:

```bash
# Watch all job events in real-time
naq events
```

This will show a live stream of all job lifecycle events as they happen. Now go back to your `main.py` and run it again to see the events flowing:

```bash
python main.py
```

You should see events like:
```
12:34:56.789  job-abc123   enqueued      default  -        Job enqueued to default
12:34:56.823  job-abc123   started       default  worker-1 Job started by worker-1  
12:34:59.156  job-abc123   completed     default  worker-1 Job completed in 2333ms
```

### Monitor Specific Jobs

You can also monitor events for a specific job:

```bash
# Monitor events for a specific job ID
naq events --job-id job-abc123

# Monitor only failed jobs
naq events --event-type failed

# Monitor events for a specific queue
naq events --queue my-queue
```

### Job Event History

Get the complete event history for any job:

```bash
# Get event history for a specific job
naq event-history job-abc123
```

This shows the complete lifecycle of a job with timestamps, durations, and detailed information.

### Worker Status Monitoring

Monitor your workers' health and activity:

```bash
# Watch worker lifecycle events
naq worker-events

# Check worker status
naq list-workers
```

### System Health

Get overall system statistics:

```bash
# Show system event statistics
naq event-stats
```

### Why This Matters

This comprehensive monitoring gives you:

- **Instant Visibility**: See exactly what's happening with your jobs
- **Easy Debugging**: Trace job failures with complete event history  
- **Performance Insights**: Monitor job durations and worker utilization
- **Production Readiness**: Built-in observability for production deployments

## What's Next?

-   Learn about [Event-Driven State Management](event-logging.qmd) for advanced monitoring.
-   Explore how to [schedule jobs](examples.qmd) to run in the future.
-   Learn about the [architecture](architecture.qmd) of `naq`.
-   Check out more complex [examples](examples.qmd).